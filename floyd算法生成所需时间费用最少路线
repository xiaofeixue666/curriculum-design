//用矩阵D来保存费用这个权值，用P来保存路径
//开的空间比较大，要用用全局变量，否则在函数内部定义会造成堆栈溢出
long long D[MVNum][MVNum], P[MVNum][MVNum];

//用Folyd算法生成当前城市能到达的所有城市
void Floyd_path(graph G, char city[]) {
	int v = -1;
	for (int i = 0; i < G->Nv; i++)//对两个矩阵进行初始化
		if (strcmp(G->G[i].CityName, city) == 0) {
			v = i;
			break;
		}

	for (int i = 0; i < G->Nv; i++)//对Path矩阵进行初始化
		for (int j = 0; j < G->Nv; j++) {
			P[i][j] = -1;//
		}
	//memset(P,-1,sizeof P);
	for (int i = 0; i < G->Nv; i++) {
		adjoin p = G->G[i].FirstEdge;
		while (p != NULL) {
			P[i][p->adjv] = 1;
			P[p->adjv][i] = 1;
			p = p->Next;
		}
	}

	for (int k = 0; k < G->Nv; k++)//floyd算法
		for (int i = 0; i < G->Nv; i++)
			for (int j = 0; j < G->Nv; j++)
				if (P[i][k] == 1 && P[k][j] == 1) {
					P[i][j] = 1;
				}

	printf("%s 能够到达的所有城市:", G->G[v].CityName);
	for (int i = 0; i < G->Nv; i++) {
		if (P[v][i] == 1 && v != i)
			printf("%s ", G->G[i].CityName);
	}
	printf("\n\n");
}

//用该函数来递归查找P数组中的路径
void print_path(graph G, int i, int j) {
	int k = P[i][j];//找到上一个中转站/顶点（中转城市）
	if (k == -1)
		//说明没有中转顶点，直接返回
		return;
	print_path(G, i, k);//寻找i和k之间
	printf("%s->", G->G[k].CityName);
	print_path(G, k, j);//寻找k和j之间

}

//用Folyd算法生成任意两个城市之间的费用最少的路线
bool Floyd_Cost(graph G, int v1, int v2) {
	for (int i = 0; i < G->Nv; i++)//对两个矩阵进行初始化
		for (int j = 0; j < G->Nv; j++) {
			if (i == j)D[i][j] = 0;//如果相同说明是同一点
			else D[i][j] = INT_MAX;//否则先全部赋值为无穷大
			P[i][j] = -1;//一开始路径都没有
		}
	for (int i = 0; i < G->Nv; i++) {//记录所有相邻城市之间的费用
		adjoin p = G->G[i].FirstEdge;
		while (p != NULL) {
			D[i][p->adjv] = p->cost;//将边上的费用这个权值赋给数组D
			p = p->Next;
		}
	}
	for (int k = 0; k < G->Nv; k++)//floyd算法
		for (int i = 0; i < G->Nv; i++)
			for (int j = 0; j < G->Nv; j++)
				if (D[i][k] + D[k][j] < D[i][j]) {
					D[i][j] = D[i][k] + D[k][j];
					//因为路费不会是负数，所以不用加特判了
					if (i != j)P[i][j] = k;
				}
	if (D[v1][v2] >= INT_MAX) return false;
	//如果最后的路线总费用大于等定义好的无穷大，那么说明路线不存在
	printf("从 %s 至 %s 花费最小的路线为:%s->", G->G[v1].CityName, G->G[v2].CityName, G->G[v1].CityName);
	print_path(G, v1, v2);
	printf("%s 共花费%d元\n\n", G->G[v2].CityName, D[v1][v2]);
	return true;
}

//用Folyd算法生成任意两个城市之间的路程最少的路线
void Floyd_Mileage(graph G, int v1, int v2) {
	for (int i = 0; i < G->Nv; i++)//对两个矩阵进行初始化
		for (int j = 0; j < G->Nv; j++) {
			if (i == j)D[i][j] = 0;//如果相同说明是同一点
			else D[i][j] = INT_MAX;//否则先全部赋值为无穷大
			P[i][j] = -1;//一开始路径都没有
		}
	for (int i = 0; i < G->Nv; i++) {//记录所有相邻城市之间的路程
		adjoin p = G->G[i].FirstEdge;
		while (p != NULL) {
			D[i][p->adjv] = p->mileage;//将边上的费用这个权值赋给数组D
			p = p->Next;
		}
	}
	for (int k = 0; k < G->Nv; k++)//floyd算法
		for (int i = 0; i < G->Nv; i++)
			for (int j = 0; j < G->Nv; j++)
				if (D[i][k] + D[k][j] < D[i][j]) {
					D[i][j] = D[i][k] + D[k][j];
					//因为路程不会是负数，所以不用加特判了
					if (i != j)P[i][j] = k;
				}
	printf("从 %s 至 %s 路程最小的路线为:%s->", G->G[v1].CityName, G->G[v2].CityName, G->G[v1].CityName);
	print_path(G, v1, v2);
	printf("%s 共有%dkm的路程\n\n", G->G[v2].CityName, D[v1][v2]);
}

//用Folyd算法生成任意两个城市之间的所用时间最少的路线
void Floyd_Time(graph G, int v1, int v2) {
	for (int i = 0; i < G->Nv; i++)//对两个矩阵进行初始化
		for (int j = 0; j < G->Nv; j++) {
			if (i == j)D[i][j] = 0;//如果相同说明是同一点
			else D[i][j] = INT_MAX;//否则先全部赋值为无穷大
			P[i][j] = -1;//一开始路径都没有
		}
	for (int i = 0; i < G->Nv; i++) {//记录所有相邻城市之间的时间
		adjoin p = G->G[i].FirstEdge;
		while (p != NULL) {
			D[i][p->adjv] = p->time;//将边上的费用这个权值赋给数组D
			p = p->Next;
		}
	}
	for (int k = 0; k < G->Nv; k++)//floyd算法
		for (int i = 0; i < G->Nv; i++)
			for (int j = 0; j < G->Nv; j++)
				if (D[i][k] + D[k][j] < D[i][j]) {
					D[i][j] = D[i][k] + D[k][j];
					//因为时间不会是负数，所以不用加特判了
					if (i != j)P[i][j] = k;
				}
	printf("从 %s 至 %s 所花时间最少的路线为:%s->", G->G[v1].CityName, G->G[v2].CityName, G->G[v1].CityName);
	print_path(G, v1, v2);
	printf("%s 共需时间%d分钟\n\n", G->G[v2].CityName, D[v1][v2]);
}
