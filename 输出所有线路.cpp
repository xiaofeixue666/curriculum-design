//将所有的路线进行输出
void Show_Path(graph G) {
	system("cls");
	printf("-----------------------------------------------------路线总表-----------------------------------------------------------\n");
	printf("________________________________________________________________________________________________________________________\n");
	printf("|%10s\t\t|%10s\t\t|%10s\t\t|%10s\t\t|%10s\t\t|\n", "起点", "终点", "路程(千米)", "费用(元)", "时间(分)");
	printf("________________________________________________________________________________________________________________________\n");
	bool vis[MVNum][MVNum] = { false };//开一个布尔类型的二维数组进行标记，防止重复输出相同的路线
	for (int i = 0; i < G->Nv; i++) {
		adjoin p = G->G[i].FirstEdge;//将指针指向邻接表的该位置的表头结点的下一个结点
		bool flag = false;//定义一个标记用于换行输出
		while (p != NULL) {
			if (!vis[i][p->adjv] && !vis[p->adjv][i]) {
				//printf("%s到%s(反方向相同) 所需路程：%d 所需路费：%d 所需时间：%d", G->G[i].CityName, p->CityName, p->mileage, p->cost, p->time);
				printf("|%10s\t\t|%10s\t\t|%10d\t\t|%10d\t\t|%10d\t\t|", G->G[i].CityName, p->CityName, p->mileage, p->cost, p->time);
				vis[i][p->adjv] = true;//将路线输出后进行标记
				vis[p->adjv][i] = true;
				flag = true;
			}
			p = p->Next;
			if (flag) {//如果标记变为真，说明有了输出，进行换行
				printf("\n________________________________________________________________________________________________________________________\n");
				flag = false;//重新标记为假
			}
		}
	}

}

//用矩阵D来保存费用这个权值，用P来保存路径
//开的空间比较大，要用用全局变量，否则在函数内部定义会造成堆栈溢出
