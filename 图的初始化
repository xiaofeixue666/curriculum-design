//实现图的头文件，用邻接表实现
//#include"queue.h"//引入队列头文件，其中已包含头文件和结构体

//定义/初始化一个图，如果文件中有路线也把路线插入图中
graph CreateG();

//判断图是否为空
bool empty(graph G);

//在图G中查找城市名称，如果不存在则返回错误信息ERROR，存在则返回该城市所在邻接表的下标位置
int Search_CityName(graph G, char city[]);

//往图G中插入一条新的路线E
void Insert_Path(graph G, edge E);

//将邻接表进行输出，测试用
void show(graph G);

//将所有的路线进行输出
void Show_Path(graph G);

//将图中的某条路线进行修改
void Modify_Path(graph G, edge E);

//将图进行保存,格式为：城市1 城市2 路程 费用 时间
bool Save_File(graph G);

//读取文件，将文件中的路线全部输进邻接表中
bool Read_File(graph G);

//用该函数来递归查找P数组中的路径
void print_path(graph G, int i, int j);

//用Folyd算法生成当前城市能到达的所有城市
void Floyd_path(graph G, char city[]);

//用Folyd算法生成任意两个城市之间的费用最少的路线
void Floyd_Cost(graph G, char city1[], char city2[]);

//用Folyd算法生成任意两个城市之间的路程最少的路线
void Floyd_Mileage(graph G, char city1[], char city2[]);

//用Folyd算法生成任意两个城市之间的所用时间最少的路线
void Floyd_Time(graph G, char city1[], char city2[]);

//用广度优先搜索算法搜索中转站最少的路线，需要用到队列
void Bfs(graph G, char city1[], char city2[]);

//将v1到v2的中转站最少的路线打印出来
void Print_Path(graph G, int v1, int v2);



//定义/初始化一个图
graph CreateG() {
	graph G = (graph)malloc(sizeof(struct GNode));//建立图/开辟空间
	G->Ne = 0;//初始边数为0
	G->Nv = 0;//初始的顶点/城市数目也为0
	for (int i = 0; i < MVNum; i++)//将图中的全部顶点的表头指针赋为空NULL
		G->G[i].FirstEdge = NULL;
	Read_File(G);//将文件中的路线输入图中
	return G;//将图返回
}
