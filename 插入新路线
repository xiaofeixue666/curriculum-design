//往图G中插入一条新的路线
void Insert_Path(graph G, edge E) {
	E->v1 = Search_CityName(G, E->city1);//现在原先的邻接表中查找两城市的位置
	E->v2 = Search_CityName(G, E->city2);
	if (E->v1 == -1)E->v1 = G->Nv++;//没找到就在图中加入新的点，同时图中的顶点数+1
	if (E->v2 == -1)E->v2 = G->Nv++;
	adjoin p = (adjoin)malloc(sizeof(struct AdjVNode));//开辟一个新的邻接点
	p->adjv = E->v2; p->cost = E->cost;//给邻接点赋值：
	p->mileage = E->mileage; p->time = E->time; strcpy(p->CityName, E->city2);
	strcpy(G->G[E->v1].CityName, E->city1);//将城市名称放入顶点数据
	adjoin s = G->G[E->v1].FirstEdge;//用尾插法将邻接点与邻接表进行连接
	if (s == NULL) {
		p->Next = G->G[E->v1].FirstEdge;
		G->G[E->v1].FirstEdge = p;
	}
	else {
		while (s->Next != NULL)s = s->Next;
		p->Next = s->Next;
		s->Next = p;
	}
	adjoin q = (adjoin)malloc(sizeof(struct AdjVNode));//无向边需要在边的两头都加入邻接点
	q->adjv = E->v1; q->cost = E->cost;//给邻接点赋值
	q->mileage = E->mileage; q->time = E->time; strcpy(q->CityName, E->city1);
	strcpy(G->G[E->v2].CityName, E->city2);//将城市名称放入顶点数据
	s = G->G[E->v2].FirstEdge;//用尾插法将邻接点与邻接表进行连接
	if (s == NULL) {
		q->Next = G->G[E->v2].FirstEdge;
		G->G[E->v2].FirstEdge = q;
	}
	else {
		while (s->Next != NULL)s = s->Next;
		q->Next = s->Next;
		s->Next = q;
	}
	G->Ne++;//最后图的边的数目+1
}

//将邻接表进行输出，测试用
void show(graph G) {
	for (int i = 0; i < G->Nv; i++) {
		printf("%s 可以去的城市:", G->G[i].CityName);
		adjoin p = G->G[i].FirstEdge;//将指针指向邻接表的该位置的表头结点的下一个结点
		while (p != NULL) {
			printf("%s（费用为：%d） ", p->CityName, p->cost);
			p = p->Next;
		}
		printf("\n\n");
	}
}
